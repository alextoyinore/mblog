<% if (locals.latestSongs.length) { %> 
  <section class="mb-8 mt-8 overflow-x-hidden">
    <h2 class="font-instrument mt-4 text-lg font-bold dark:text-white flex-1 mb-4 pb-2 border-b border-gray-200 dark:border-gray-700">
      <% if (locals.title) { %>
        <%= title %>
      <% } else { %>
        New Arrivals
      <% } %>
    </h2>

    <div class="flex flex-col gap-0">
      <% locals.latestSongs.forEach(song => { %>
        <%- include('./playitem', {song:song}) %>
      <% }) %> 
    </div>
  </section>
<% } %>

<style>
.play-indicator {
  transition: opacity 0.2s ease-in-out;
}

@keyframes ping {
  75%, 100% {
    transform: scale(2);
    opacity: 0;
  }
}

.animate-ping {
  animation: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;
}

.song-item:hover {
  background-color: rgba(0, 0, 0, 0.025);
}

.dark .song-item:hover {
  background-color: rgba(255, 255, 255, 0.025);
}
</style>

<script>
function handleLatestSongPlay(element, songId, songUrl, songTitle, artistName, artworkUrl) {
  if (!songUrl) return;

  const songItem = element.closest('.song-item');
  const allSongItems = document.querySelectorAll('.song-item');
  const playIndicator = songItem.querySelector('.play-indicator');
  const artwork = songItem.querySelector('.song-artwork');

  // Reset all other songs first
  allSongItems.forEach(item => {
    if (item !== songItem) {
      const otherIndicator = item.querySelector('.play-indicator');
      const otherArtwork = item.querySelector('.song-artwork');
      otherIndicator.classList.add('hidden');
      otherArtwork.classList.remove('hidden');
    }
  });

  // If this is the current song
  if (currentAudio && currentAudio.dataset.songId === songId) {
    if (currentAudio.paused) {
      // Resume playing
      currentAudio.play();
      artwork.classList.add('hidden');
      playIndicator.classList.remove('hidden');
    } else {
      // Pause playing
      currentAudio.pause();
      artwork.classList.remove('hidden');
      playIndicator.classList.add('hidden');
    }
  } else {
    // Stop any currently playing song
    if (currentAudio) {
      currentAudio.pause();
      currentAudio = null;
    }

    // Create and play new audio
    currentAudio = new Audio(songUrl);
    currentAudio.dataset.songId = songId;

    currentAudio.play().then(() => {
      // Show play indicator
      artwork.classList.add('hidden');
      playIndicator.classList.remove('hidden');
      
      // Create/show mini player
      createMiniPlayer(songId, songTitle, artistName, artworkUrl);

      // Increment plays
      incrementPlays(songId);
    }).catch(error => {
      console.error('Error playing audio:', error);
      artwork.classList.remove('hidden');
      playIndicator.classList.add('hidden');
    });

    // Handle song end
    currentAudio.addEventListener('ended', () => {
      if (!isLooping) {
        artwork.classList.remove('hidden');
        playIndicator.classList.add('hidden');
        if (miniPlayer) {
          miniPlayer.classList.add('translate-y-full');
        }
      }
    });
  }
}

// Listen for mini player controls
document.addEventListener('miniPlayerStateChange', (e) => {
  const { songId, isPlaying } = e.detail;
  const songItem = document.querySelector(`.song-item[data-song-id="${songId}"]`);
  if (songItem) {
    const playIndicator = songItem.querySelector('.play-indicator');
    const artwork = songItem.querySelector('.song-artwork');
    
    if (isPlaying) {
      artwork.classList.add('hidden');
      playIndicator.classList.remove('hidden');
    } else {
      artwork.classList.remove('hidden');
      playIndicator.classList.add('hidden');
    }
  }
});
</script>